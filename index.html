<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rompecabezas Glitch</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=DotGothic16&family=Inter:wght@700&family=Permanent+Marker&display=swap" rel="stylesheet">
    <style>
        /* Apply border-box globally for consistent sizing */
        *, *::before, *::after {
            box-sizing: border-box;
        }

        /* CSS variables definition for colors */
        :root {
            --color-dark-base: #222222;    /* The dark gray for the left side of the background */
            --color-yellow-base: #ffd414;  /* The bright yellow for the right side of the background */
            /* Vivid colors for the internal "flashes" */
            --flash-dark-side-color: #5e5e5e; /* Darker gray for the flash on the dark side */
            --flash-yellow-side-color: #FF8200; /* A more intense orange for the flash on the yellow side */
            --yellowish-green: #ADFF2F; /* New yellowish-green color */
            --darker-yellowish-green: #90EE90; /* A slightly darker shade for hover effect */
            
            /* Nueva variable para el tamaño responsivo de las piezas del puzzle */
            --puzzle-piece-size: clamp(80px, 15vw, 100px); /* Min 80px, Max 100px, escala con el 15% del ancho del viewport */
        }

        body {
            font-family: 'DotGothic16', sans-serif; /* Keep DotGothic16 as default body font */
            color: #e2e8f0; /* General light text color */
            margin: 0;
            padding: 0;
            min-height: 100vh; /* Ensures the body takes full viewport height */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative; /* Necessary for absolutely positioned background elements */
            overflow: hidden; /* Prevents scrollbars due to large flashes */
            -webkit-user-select: none;  /* Disable text selection for WebKit browsers */
            -moz-user-select: none;     /* Disable text selection for Firefox */
            -ms-user-select: none;      /* Disable text selection for Internet Explorer/Edge */
            user-select: none;          /* Standard property to disable text selection */
        }
        
        /* Style for the main title to use a bold, non-pixel font */
        .main-title-font {
            font-family: 'Inter', sans-serif;
            font-weight: 700; /* Bold weight for Inter font */
        }

        /* Style for the new hand-drawn font - specifically for "Eso ta Perfect" */
        .hand-drawn-font {
            font-family: 'Permanent Marker', cursive !important; /* Use !important to ensure it overrides other font rules */
        }

        /* Container for the static background split diagonally */
        .background-split {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('https://i.imgur.com/CmVWQdv.png');
            background-size: 120%; /* Made larger to avoid empty space during movement */
            background-repeat: no-repeat;
            z-index: -2;
            animation: background-move-diagonal 8s ease-in-out infinite alternate; /* New animation for smooth diagonal movement, now 8s */
        }

        /* Keyframes for the background image smooth diagonal movement */
        @keyframes background-move-diagonal {
            0% { background-position: 45% 40%; } /* Start (up): slightly left, slightly up */
            100% { background-position: 55% 60%; } /* End (down): slightly right, slightly down */
        }

        /* Overlay layer for the "breathing" effects */
        .flash-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1; /* Positions it above the static background but below main content */
            pointer-events: none; /* Allows clicks to pass through this layer */
        }

        /* Base style for pseudo-elements that will create the "flashes" */
        .flash-overlay::before,
        .flash-overlay::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 150vw; /* Large width to ensure they cover the entire screen */
            height: 150vh; /* Large height to ensure they cover the entire screen */
            border-radius: 50%; /* Round shape for the flashes */
            background-repeat: no-repeat;
            background-size: cover;
            transform: translate(-50%, -50%) scale(0.2); /* Starts small and in the center */
            opacity: 0; /* Starts invisible */
            animation: pulse-flash 4s ease-in-out infinite; /* "Breathing" animation */
        }

        /* Flash on the left side (dark gray) */
        .flash-overlay::before {
            background-image: radial-gradient(circle at center, var(--flash-dark-side-color) 0%, transparent 60%);
            /* Clips the flash so it's only visible on the left side of the diagonal */
            mask-image: linear-gradient(70deg, black 50%, transparent 50%);  
            -webkit-mask-image: linear-gradient(70deg, black 50%, transparent 50%); /* Prefix for compatibility */
            animation-delay: 0s; /* Starts immediately */
        }

        /* Keyframes for the "breathing" animation of the flashes */
        @keyframes pulse-flash {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.2); }
            50% { opacity: 0.9; transform: translate(-50%, -50%) scale(1.2); } /* Flash expands and becomes more visible, increased opacity and size */
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.2); } /* Flash fades out and contracts */
        }

        /* New overlay for Ben Day dots using SVG images */
        .ben-day-dots-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0; /* Below puzzle-wrapper content (z-index 1) but above flash-overlay (-1) */
            pointer-events: none; /* Allows interaction with elements below */

            /* SVG for a tiny black circle, repeated for the pattern */
            /* The SVG is a 6x6 pixel canvas with a black circle of radius 1.5px centered in it. */
            /* This gives a 3px diameter circle. */
            background-image: 
                url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My4xLjYvMjAwMC9zdmciIHdpZHRoPSI2IiHoZWlnaHQ9IjYiPjxjaXJjY2xlIGN4PSAzIiBjeT0iMyIgcj0iMS41IiBmaWxsPSJibGFjayIvPjwvc3ZnPg=='),
                url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My4xLjYvMjAwMC9zdmciIHdpZHRoPSI2IiHoZWlnaHQ9IjYiPjxjaXJjY2xlIGN4PSAzIiBjeT0iMyIgcj0iMS41IiBmaWxsPSJibGFjayIvPjwvc3ZnPg==');
            
            /* Controls the spacing of the repeated SVG circles (each SVG is 6x6) */
            background-size: 6px 6px; 
            /* Offsets the second SVG pattern by half of the background-size for a diagonal grid */
            background-position: 0 0, 3px 3px; 
            background-repeat: repeat; /* Ensure the SVG pattern repeats across the overlay */

            /* Mask to create the fading effect (denser at bottom, fading to top) */
            mask-image: linear-gradient(to top,
                rgba(0,0,0,1) 0%,    /* Fully opaque at the very bottom */
                rgba(0,0,0,1) 30%,   /* Stays fully opaque for the first 30% */
                rgba(0,0,0,0.85) 60%, /* Starts fading, but remains very dark up to 60% */
                rgba(0,0,0,0.4) 90%, /* Fades to 40% opacity by 90% height */
                rgba(0,0,0,0) 100%   /* Fully transparent at the top */
            );
            -webkit-mask-image: linear-gradient(to top,
                rgba(0,0,0,1) 0%,
                rgba(0,0,0,1) 30%,
                rgba(0,0,0,0.85) 60%,
                rgba(0,0,0,0.4) 90%,
                rgba(0,0,0,0) 100%
            );
        }

        .puzzle-wrapper {
            position: relative; /* Needed for pseudo-element positioning */
            background-color: #d97706; /* Orange for the "windows" */
            padding: 1.5rem;
            box-shadow: none; 
            overflow: hidden;
            border-radius: 0.5rem; /* More rounded corners (8px) */
            animation: glitch-wrapper-up-down-keyframes 4s steps(6, end) infinite; 
            
            /* Controla el tamaño general del puzzle wrapper para que sea responsivo */
            width: 90vw; /* Ocupa el 90% del ancho del viewport */
            max-width: 800px; /* Pero no más de 800px en pantallas grandes */
            margin-left: auto; /* Centrar horizontalmente */
            margin-right: auto; /* Centrar horizontalmente */
        }
        
        /* Pseudo-element for the animated white border on puzzle-wrapper */
        .puzzle-wrapper::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-top: 2px solid transparent; /* Animated */
            border-left: 2px solid transparent; /* Animated */
            pointer-events: none; /* Allows clicks to pass through */
            border-radius: 0.5rem; /* Match parent border-radius */
            animation: fade-border-white-pseudo 4s ease-in-out infinite; /* Smooth fade animation */
            z-index: 2; /* Above canvas, below content */
        }

        /* Keyframes for the pseudo-element border fade animation */
        @keyframes fade-border-white-pseudo {
            0%, 100% {
                border-color: rgba(255, 255, 255, 0); /* Transparent */
            }
            50% {
                border-color: rgba(255, 255, 255, 1); /* Opaque white */
            }
        }

        #dot-canvas, #modal-dot-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0; /* Ensures dots are below the puzzle window content */
        }
        
        .content-grid {
            position: relative;
            z-index: 1; /* Ensures content is above the canvas dots and Ben Day dots */
            display: flex; /* Siempre flex */
            flex-direction: row; /* Siempre en fila */
            justify-content: center; /* Centrar contenido */
            align-items: flex-start; /* Alinear arriba */
            gap: 1rem; /* Espacio entre los contenedores de fragmentos y lienzo (reducido para móvil) */
            flex-wrap: nowrap; /* Evita que los elementos se envuelvan a una nueva línea */
        }
        /* Ajustar el gap para pantallas más grandes si es necesario */
        @media (min-width: 768px) { /* md breakpoint */
            .content-grid {
                gap: 3rem; /* gap-12 en Tailwind es 3rem */
            }
        }

        .puzzle-area {
            padding: 1rem;
            border-radius: 0.5rem; 
            box-shadow: none; 
            flex-shrink: 0; /* Evita que los elementos se encojan más allá de su contenido */
            flex-basis: 50%; /* Intenta que cada área ocupe la mitad del espacio disponible */
            min-width: 280px; /* Establece un ancho mínimo para evitar que se hagan demasiado pequeños */
        }

        /* Specific gradient for the left puzzle area */
        .puzzle-area-left {
            background: linear-gradient(to top left, var(--color-yellow-base) 15%, #FF8C00); 
        }

        /* Specific gradient for the right puzzle area */
        .puzzle-area-right {
            background: linear-gradient(to top right, var(--color-yellow-base) 15%, #FF8C00); 
        }

        /* Set a fixed minimum height for the pieces container */
        #pieces-container {
            min-height: calc(2 * var(--puzzle-piece-size) + 2 * 0.5rem); /* Ajusta la altura mínima basada en el tamaño de la pieza */
            display: grid;
            grid-template-columns: repeat(3, var(--puzzle-piece-size)); /* Columnas basadas en el tamaño de la pieza */
            gap: 0.5rem; /* gap-2 en Tailwind es 0.5rem */
            justify-content: center;
        }

        #puzzle-grid {
            display: grid;
            grid-template-columns: repeat(3, var(--puzzle-piece-size)); /* Columnas basadas en el tamaño de la pieza */
            gap: 0.5rem; /* gap-2 en Tailwind es 0.5rem */
            justify-content: center;
        }

        .puzzle-piece, .puzzle-slot {
            width: var(--puzzle-piece-size); /* Usa la variable de tamaño responsivo */
            height: var(--puzzle-piece-size); /* Usa la variable de tamaño responsivo */
            /* Cambiado a porcentajes para que la imagen de fondo escale correctamente */
            background-size: 300% 200%; 
            border-radius: 8px; 
            image-rendering: pixelated;
        }
        .puzzle-piece {
            cursor: grab;
            box-shadow: 4px 4px 0px rgba(0,0,0,0.5); 
            transition: transform 0.2s steps(2, end), box-shadow 0.2s steps(2, end); 
        }
        .puzzle-piece:hover {
            transform: scale(1.05);
            box-shadow: 6px 6px 0px rgba(0,0,0,0.7); 
        }
        .puzzle-piece.dragging {
            cursor: grabbing;
            transform: scale(1.1) translateY(-5px); 
            box-shadow: 12px 12px 0px rgba(96, 96, 96, 0.8); 
            transition: transform 0.15s ease-out, box-shadow 0.15s ease-out; 
            z-index: 100; 
        }

        .puzzle-slot {
            background-color: rgba(0,0,0,0.2);
            border: none; 
            border-radius: 8px; 
            transition: none; 
        }
        .puzzle-slot.correct {
            border-color: #4ade80;
            background-color: rgba(74, 222, 128, 0.3);
            animation: correct-slot-pulse 0.05s ease-out; 
        }
        .puzzle-slot.over { transform: scale(1.03); border-color: #ffffff; }
        
        .modal-container { transition: opacity 0.3s ease, visibility 0.3s ease; }

        /* Style for main title text (h1) */
        .glitch-main-title-animation {
            text-shadow: 8px 8px 0px rgba(0,0,0,1), -0.3px -0.3px 0px rgba(255,255,255,0); 
            font-family: 'Inter', sans-serif; 
        }

        /* Style for sub-text glitch animation */
        .glitch-subtext-animation {
            text-shadow: 4px 4px 0px rgba(0,0,0,1);
            font-family: 'Inter', sans-serif; 
            font-weight: 700; 
        }
        /* Specific override for the modal title to ensure hand-drawn font */
        .puzzle-area .hand-drawn-font {
            font-family: 'Permanent Marker', cursive !important; 
        }

        /* New keyframes for correct slot pulse */
        @keyframes correct-slot-pulse {
            0% {
                transform: scale(1);
                background-color: rgba(74, 222, 128, 0.1);
            }
            50% { 
                transform: scale(1.02);
                background-color: rgba(74, 222, 128, 0.5);
            }
            100% {
                transform: scale(1);
                background-color: rgba(74, 222, 128, 0.3);
            }
        }

        /* Keyframes for the main title's glitch animation (movement, black shadow, and white outline) */
        @keyframes glitch-main-title-keyframes {
            0%, 100% { 
                transform: translate(0, 0) rotate(0) scale(1); 
                text-shadow: 8px 8px 0px rgba(0,0,0,1), 
                             -0.3px -0.3px 0px rgba(255,255,255,0); 
            }
            10% { 
                transform: translate(-0.1%, 0.1%) rotate(-0.1deg) scale(1.002); 
                text-shadow: 8.5px 7.5px 0px rgba(0,0,0,1), 
                             -0.5px -0.1px 0px rgba(255,255,255,0.9); 
            } 
            20% { 
                transform: translate(0.1%, -0.1%) rotate(0.1deg) scale(0.998); 
                text-shadow: 7.5px 8.5px 0px rgba(0,0,0,1), 
                             -0.1px -0.5px 0px rgba(255,255,255,0.9); 
            }
            30% { 
                transform: translate(-0.1%, 0.1%) rotate(-0.1deg) scale(1.002); 
                text-shadow: 8.5px 7.5px 0px rgba(0,0,0,1), 
                             -0.5px -0.1px 0px rgba(255,255,255,0.9); 
            }
            40% { 
                transform: translate(0.1%, -0.1%) rotate(0.1deg) scale(0.998); 
                text-shadow: 7.5px 8.5px 0px rgba(0,0,0,1), 
                             -0.1px -0.5px 0px rgba(255,255,255,0); 
            }
            50% { 
                transform: translate(-0.1%, 0.1%) rotate(-0.1deg) scale(1.002); 
                text-shadow: 8.5px 7.5px 0px rgba(0,0,0,1), 
                             -0.5px -0.1px 0px rgba(255,255,255,0); 
            }
            60% { 
                transform: translate(0.1%, -0.1%) rotate(0.1deg) scale(0.998); 
                text-shadow: 7.5px 8.5px 0px rgba(0,0,0,1), 
                             -0.1px -0.5px 0px rgba(255,255,255,0.9); 
            }
            70% { 
                transform: translate(-0.1%, 0.1%) rotate(-0.1deg) scale(1.002); 
                text-shadow: 8.5px 7.5px 0px rgba(0,0,0,1), 
                             -0.5px -0.1px 0px rgba(255,255,255,0.9); 
            }
            80% { 
                transform: translate(0.1%, -0.1%) rotate(0.1deg) scale(0.998); 
                text-shadow: 7.5px 8.5px 0px rgba(0,0,0,1), 
                             -0.1px -0.5px 0px rgba(255,255,255,0.9); 
            }
            90% { 
                transform: translate(-0.1%, 0.1%) rotate(-0.1deg) scale(1.001); 
                text-shadow: 8.5px 7.5px 0px rgba(0,0,0,1), 
                             -0.5px -0.1px 0px rgba(255,255,255,0); 
            }
        }

        /* Keyframes for sub-text glitch animation */
        @keyframes glitch-subtext-keyframes {
            0%, 100% { 
                transform: translate(0, 0) rotate(0) scale(1); 
                text-shadow: 4px 4px 0px rgba(0,0,0,1); 
            }
            10% { 
                transform: translate(-0.05%, 0.05%) rotate(-0.05deg) scale(1.001); 
                text-shadow: 4.05px 3.95px 0px rgba(0,0,0,1); 
            } 
            20% { 
                transform: translate(0.05%, -0.05%) rotate(0.05deg) scale(0.999); 
                text-shadow: 3.95px 4.05px 0px rgba(0,0,0,1); 
            }
            30% { 
                transform: translate(-0.05%, 0.05%) rotate(-0.05deg) scale(1.001); 
                text-shadow: 4.05px 3.95px 0px rgba(0,0,0,1);
            }
            40% { 
                transform: translate(0.05%, -0.05%) rotate(0.05deg) scale(0.999); 
                text-shadow: 3.95px 4.05px 0px rgba(0,0,0,1);
            }
            50% { 
                transform: translate(-0.05%, 0.05%) rotate(-0.05deg) scale(1.001); 
                text-shadow: 4.05px 3.95px 0px rgba(0,0,0,1);
            }
            60% { 
                transform: translate(0.05%, -0.05%) rotate(0.05deg) scale(0.999); 
                text-shadow: 3.95px 4.05px 0px rgba(0,0,0,1);
            }
            70% { 
                transform: translate(-0.05%, 0.05%) rotate(-0.05deg) scale(1.001); 
                text-shadow: 4.05px 3.95px 0px rgba(0,0,0,1);
            }
            80% { 
                transform: translate(0.05%, -0.05%) rotate(0.05deg) scale(0.999); 
                text-shadow: 3.95px 4.05px 0px rgba(0,0,0,1);
            }
            90% { 
                transform: translate(-0.05%, 0.05%) rotate(-0.05deg) scale(1.001); 
                text-shadow: 4.05px 3.95px 0px rgba(0,0,0,1);
            }
        }

        /* Keyframes for the puzzle wrapper and its box-shadow glitch effect (up-down zigzag) */
        @keyframes glitch-wrapper-up-down-keyframes {
            0%, 100% {
                transform: translateY(0%);
                box-shadow: 8px 8px 0px rgba(0,0,0,0.95);
            }
            16.66% { /* Moving up */
                transform: translateY(-0.8%); /* Consistent upward move */
                box-shadow: 8px 8.8px 0px rgba(0,0,0,0.95);
            }
            33.33% { /* Peak Up */
                transform: translateY(-1.5%); /* Max upward move */
                box-shadow: 8px 9.5px 0px rgba(0,0,0,0.95);
            }
            50% { /* Moving down through center */
                transform: translateY(-0.8%); /* Consistent downward move */
                box-shadow: 8px 8.8px 0px rgba(0,0,0,0.95);
            }
            66.66% { /* Moving down past center */
                transform: translateY(0.5%); /* Consistent downward move */
                box-shadow: 8px 7.5px 0px rgba(0,0,0,0.95);
            }
            83.33% { /* Peak Down */
                transform: translateY(1.0%); /* Max downward move */
                box-shadow: 8px 7.0px 0px rgba(0,0,0,0.95);
            }
        }
        
        /* Animation properties for main title */
        .glitch-main-title-animation {
            animation-name: glitch-main-title-keyframes;
            animation-duration: 2.5s; /* All parts of the animation use this duration */
            animation-iteration-count: infinite;
            animation-timing-function: steps(1, end); 
        }

        /* Animation properties for sub-texts */
        .glitch-subtext-animation {
            animation-name: glitch-subtext-keyframes;
            animation-duration: 2.5s;
            animation-iteration-count: infinite;
            animation-timing-function: steps(1, end);
            font-weight: 700; 
        }

        /* Style for the retry button */
        #play-again-btn {
            background-color: var(--yellowish-green); 
            border: none; 
            color: white; 
            padding: 0.75rem 1rem; 
            font-size: 2.5rem; 
            cursor: pointer;
            transition: background-color 0.3s ease;
            display: inline-flex; 
            align-items: center;
            justify-content: center;
            width: 80px; 
            height: 80px; 
            border-radius: 50%; 
            box-shadow: 0 4px 6px rgba(0,0,0,0.1); 
        }
        #play-again-btn:hover {
            background-color: var(--darker-yellowish-green); 
        }
        #play-again-btn svg {
            width: 1em; 
            height: 1em;
            fill: currentColor; 
        }

        /* Allow text selection for the prize code specifically */
        #prize-code {
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            user-select: text;
        }

    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4">

    <div class="background-split"></div>
    <div class="flash-overlay"></div>
    <div class="ben-day-dots-overlay"></div>

    <div class="text-center mb-6">
        <h1 class="text-6xl md:text-8xl font-bold uppercase glitch-main-title-animation text-amber-400 main-title-font">Puzzle Zone</h1>
        <p class="mt-4 text-3xl md:text-4xl glitch-subtext-animation text-yellow-400">Completa la obra de arte</p>
    </div>

    <div class="puzzle-wrapper">
        <canvas id="dot-canvas"></canvas>
        <div class="content-grid">
            <div class="puzzle-area puzzle-area-left">
                <h2 class="text-4xl md:text-5xl font-semibold text-center text-yellow-400 mb-4 glitch-subtext-animation">Fragmentos</h2>
                <div id="pieces-container"></div>
            </div>
            <div class="puzzle-area puzzle-area-right">
                <h2 class="text-4xl md:text-5xl font-semibold text-center text-yellow-400 mb-4 glitch-subtext-animation">Lienzo</h2>
                <div id="puzzle-grid"></div>
            </div>
        </div>
    </div>
    
    <div id="prize-modal" class="modal-container invisible opacity-0 fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center p-4 z-50">
        <div class="puzzle-wrapper w-full max-w-md text-center">
            <canvas id="modal-dot-canvas"></canvas>
            <div class="content-grid">
                <div class="puzzle-area">
                    <h2 class="text-6xl md:text-7xl font-bold mt-4 glitch-subtext-animation hand-drawn-font" style="color: var(--yellowish-green);">Eso ta Perfect</h2>
                    <div id="prize-display" class="my-4 p-3 bg-white/20" style="border-radius: 1.5rem;">
                        <p id="prize-title" class="text-3xl font-semibold text-yellow-400 glitch-subtext-animation"></p>
                        <p id="prize-code" class="text-7xl font-bold text-white tracking-wider my-1 glitch-subtext-animation hand-drawn-font"></p>
                    </div>
                    <button id="play-again-btn" aria-label="Jugar de nuevo">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M463.5 224H472c13.3 0 24-10.7 24-24V72c0-9.7-5.8-18.5-14.8-22.2s-19.3-1.7-26.2 5.2L413.4 96c-87.6-86.5-228.7-86.2-315.8 1c-87.5 87.5-87.5 229.3 0 316.8s229.3 87.5 316.8 0c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0c-62.5 62.5-163.8 62.5-226.3 0s-62.5-163.8 0-226.3c63-62.5 165.1-62.9 227.5-1.2l4.8 4.9L400 192h-40c-13.3 0-24 10.7-24 24s10.7 24 24 24H456h8c13.3 0 24-10.7 24-24V72c0-13.3-10.7-24-24-24H344c-13.3 0-24 10.7-24 24s10.7 24 24 24h40l-35.3 35.3c-28.5-28.5-68-45.3-109.8-45.3H128C57.3 128 0 185.3 0 256s57.3 128 128 128H448c17.7 0 32 14.3 32 32s-14.3 32-32 32H128C57.3 448 0 390.7 0 320V192c0-17.7 14.3-32 32-32s32 14.3 32 32v128c0 35.3 28.7 64 64 64H448c17.7 0 32 14.3 32 32s-14.3 32-32 32H128c-70.7 0-128-57.3-128-128s57.3-128 128-128H395.7L360.4 128.5c-7-6.9-17.8-8.9-26.2-5.2s-14.8 12.5-14.8 22.2V224h159.5z"/></svg>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const piecesContainer = document.getElementById('pieces-container');
            const puzzleGrid = document.getElementById('puzzle-grid');
            const prizeModal = document.getElementById('prize-modal');
            const playAgainBtn = document.getElementById('play-again-btn');
            const prizeTitle = document.getElementById('prize-title');
            const prizeCodeEl = document.getElementById('prize-code');

            const PUZZLE_ROWS = 2;
            const PUZZLE_COLS = 3;
            const PIECE_COUNT = PUZZLE_ROWS * PUZZLE_COLS;
            let correctlyPlaced = 0;
            // No longer using a global draggedPiece variable
            
            // Puzzle images using direct URLs from Imgur.
            const puzzleImages = [
                'https://i.imgur.com/OuPCcmg.jpeg', // Direct link to image 1
                'https://i.imgur.com/RTydQnq.jpeg', // Direct link to image 2
                'https://i.imgur.com/um82THp.jpeg'  // Direct link to image 3
            ];
            
            // Lista de 200 códigos únicos de 4 dígitos, cada uno con un "!" al principio
            const prizeCodes = [];
            while (prizeCodes.length < 200) {
                const code = '!' + Math.floor(1000 + Math.random() * 9000).toString(); // Add "!" here
                if (!prizeCodes.includes(code)) {
                    prizeCodes.push(code);
                }
            }
            // console.log('Pre-defined prize codes list:', prizeCodes); // Uncomment to see the list in console

            const activeAnimations = {};

            let currentPuzzleImageIndex = 0;

            function handleDragStart(e) { 
                // Set data for the drag operation: the piece's index
                e.dataTransfer.setData('text/plain', e.target.dataset.pieceIndex);
                // Set a custom drag image (optional, but can help with visual feedback)
                // e.dataTransfer.setDragImage(e.target, e.target.offsetWidth / 2, e.target.offsetHeight / 2);

                e.target.classList.add('dragging'); 
                // Make the original element completely invisible, relying on the browser's drag ghost
                e.target.style.opacity = '0'; 
            }

            function handleDragEnd(e) { 
                // This event fires whether the drop was successful or not.
                // If the piece was successfully dropped, handleDrop would have removed 'dragging' and set opacity to '1'.
                // So, we only need to reset if it still has the 'dragging' class (meaning it wasn't dropped on a valid target).
                if (e.target.classList.contains('dragging')) {
                    e.target.classList.remove('dragging'); 
                    e.target.style.opacity = '1'; // Reset opacity for the original piece
                    e.target.style.transition = 'transform 0.2s steps(2, end), box-shadow 0.2s steps(2, end)';
                }
            }

            function handleDragOver(e) { 
                e.preventDefault(); // Crucial: Allows a drop to happen on this element
                if (e.target.classList.contains('puzzle-slot') && e.target.childElementCount === 0) { 
                    e.target.classList.add('over'); 
                } 
            }

            function handleDragLeave(e) { 
                e.target.classList.remove('over'); 
            }

            function handleDrop(e) {
                e.preventDefault(); // Crucial: Prevents default browser drop behavior
                const dropZone = e.target;
                dropZone.classList.remove('over'); 

                // Retrieve the piece index from the dataTransfer object
                const droppedPieceIndex = e.dataTransfer.getData('text/plain');
                // Find the actual piece element using its data-piece-index
                const currentDroppedPiece = document.querySelector(`.puzzle-piece[data-piece-index="${droppedPieceIndex}"]`);

                if (currentDroppedPiece && dropZone.classList.contains('puzzle-slot') && dropZone.childElementCount === 0) {
                    // Check if the dropped piece matches the slot's expected index
                    if (currentDroppedPiece.dataset.pieceIndex === dropZone.dataset.slotIndex) {
                        const originalPieceTransition = currentDroppedPiece.style.transition; 
                        
                        // Disable transition for instant placement
                        currentDroppedPiece.style.transition = 'none'; 
                        // Force reflow to ensure 'transition: none' is applied immediately
                        // eslint-disable-next-line no-unused-vars
                        const forceReflow = currentDroppedPiece.offsetWidth; 
                        
                        dropZone.appendChild(currentDroppedPiece); // Place the piece in the slot
                        currentDroppedPiece.setAttribute('draggable', false); // Make piece non-draggable once placed
                        currentDroppedPiece.style.cursor = 'default'; // Change cursor for placed piece
                        currentDroppedPiece.classList.remove('dragging'); // Remove dragging class
                        currentDroppedPiece.style.opacity = '1'; // Immediately set opacity to 1 AFTER it's appended

                        // Re-enable transitions in the next animation frame for future hover effects
                        requestAnimationFrame(() => {
                            if (currentDroppedPiece && currentDroppedPiece.style) { 
                                currentDroppedPiece.style.transition = originalPieceTransition;
                            }
                        });

                        dropZone.classList.add('correct'); // Highlight the slot as correct
                        
                        correctlyPlaced++; 
                        checkCompletion(); 
                    }
                }
            }

            function setupAnimatedCanvas(canvasId) {
                if (activeAnimations[canvasId]) {
                    clearInterval(activeAnimations[canvasId].interval); 
                    if (activeAnimations[canvasId].observer) {
                        activeAnimations[canvasId].observer.disconnect();
                    }
                    delete activeAnimations[canvasId]; 
                }

                const canvas = document.getElementById(canvasId);
                if (!canvas || !canvas.getContext) return;
                const ctx = canvas.getContext('2d');
                
                const DOT_COUNT = 4; 
                const MIN_RADIUS = 60; 
                const MAX_RADIUS = 180; 
                const MIN_SPACING = 50; 
                const MAX_ATTEMPTS_PER_DOT = 100; 

                const PARTIAL_VISIBILITY_FACTOR = 0.5; 
                const EDGE_SPAWN_CHANCE = 0.7; 
                const EDGE_ZONE_PERCENT = 0.2; 

                function resizeCanvas() {
                    const container = canvas.parentElement;
                    if (!container) return; 
                    canvas.width = container.offsetWidth;
                    canvas.height = container.offsetHeight;
                }

                function draw() {
                    if (!canvas.isConnected) {
                        if (activeAnimations[canvasId]) {
                            clearInterval(activeAnimations[canvasId].interval);
                            if (activeAnimations[canvasId].observer) {
                                activeAnimations[canvasId].observer.disconnect();
                            }
                            delete activeAnimations[canvasId]; 
                        }
                        return;
                    }
                    ctx.clearRect(0, 0, canvas.width, canvas.height); 
                    
                    let placedDots = [];
                    for (let i = 0; i < DOT_COUNT; i++) {
                        let newDot = {};
                        let overlapped = true;
                        let attempts = 0;

                        while (overlapped && attempts < MAX_ATTEMPTS_PER_DOT) {
                            newDot.radius = Math.random() * (MAX_RADIUS - MIN_RADIUS) + MIN_RADIUS;

                            let xPosCandidate, yPosCandidate;

                            if (Math.random() < EDGE_SPAWN_CHANCE && canvasId === 'dot-canvas') {
                                if (Math.random() < 0.5) { 
                                    xPosCandidate = Math.random() * (canvas.width * EDGE_ZONE_PERCENT + newDot.radius * PARTIAL_VISIBILITY_FACTOR) - newDot.radius * PARTIAL_VISIBILITY_FACTOR;
                                } else { 
                                    xPosCandidate = canvas.width - (Math.random() * (canvas.width * EDGE_ZONE_PERCENT + newDot.radius * PARTIAL_VISIBILITY_FACTOR) - newDot.radius * PARTIAL_VISIBILITY_FACTOR);
                                }
                            } else {
                                xPosCandidate = Math.random() * (canvas.width + newDot.radius * PARTIAL_VISIBILITY_FACTOR * 2) - newDot.radius * PARTIAL_VISIBILITY_FACTOR;
                            }

                            if (Math.random() < EDGE_SPAWN_CHANCE && canvasId === 'dot-canvas') {
                                if (Math.random() < 0.5) { 
                                    yPosCandidate = Math.random() * (canvas.height * EDGE_ZONE_PERCENT + newDot.radius * PARTIAL_VISIBILITY_FACTOR) - newDot.radius * PARTIAL_VISIBILITY_FACTOR;
                                } else { 
                                    yPosCandidate = canvas.height - (Math.random() * (canvas.height * EDGE_ZONE_PERCENT + newDot.radius * PARTIAL_VISIBILITY_FACTOR) - newDot.radius * PARTIAL_VISIBILITY_FACTOR);
                                }
                            } else {
                                yPosCandidate = Math.random() * (canvas.height + newDot.radius * PARTIAL_VISIBILITY_FACTOR * 2) - newDot.radius * PARTIAL_VISIBILITY_FACTOR;
                            }
                            
                            newDot.x = Math.max(-newDot.radius * (1 - PARTIAL_VISIBILITY_FACTOR), Math.min(canvas.width + newDot.radius * (1 - PARTIAL_VISIBILITY_FACTOR), xPosCandidate));
                            newDot.y = Math.max(-newDot.radius * (1 - PARTIAL_VISIBILITY_FACTOR), Math.min(canvas.height + newDot.radius * (1 - PARTIAL_VISIBILITY_FACTOR), yPosCandidate));


                            overlapped = false;
                            for (let j = 0; j < placedDots.length; j++) {
                                const existingDot = placedDots[j];
                                const dx = newDot.x - existingDot.x;
                                const dy = newDot.y - existingDot.y;
                                const distance = Math.sqrt(dx * dx + dy * dy);
                                if (distance < (newDot.radius + existingDot.radius + MIN_SPACING)) {
                                    overlapped = true;
                                    break;
                                }
                            }
                            attempts++;
                        }

                        if (!overlapped) { 
                            placedDots.push(newDot);
                            const baseOpacity = 1.0 - (Math.random() * 0.15); 
                            const finalOpacity = baseOpacity * 0.6; 
                            ctx.fillStyle = `rgba(255, 215, 0, ${finalOpacity})`;
                            ctx.beginPath();
                            ctx.arc(newDot.x, newDot.y, newDot.radius, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }
                
                resizeCanvas(); 
                const animationInterval = setInterval(draw, 700); 
                const observer = new ResizeObserver(resizeCanvas); 
                
                if (canvas.parentElement) {
                    observer.observe(canvas.parentElement);
                }

                activeAnimations[canvasId] = {
                    interval: animationInterval,
                    observer: observer
                };
            }
            
            function desyncAnimations() {
                const glitchyTexts = document.querySelectorAll('.glitch-main-title-animation, .glitch-subtext-animation');
                glitchyTexts.forEach(el => {
                    el.style.animationDelay = `-${Math.random() * 2.5}s`;
                });
            }

            function setupGame() {
                correctlyPlaced = 0; 
                piecesContainer.innerHTML = ''; 
                puzzleGrid.innerHTML = ''; 
                prizeModal.classList.add('invisible', 'opacity-0'); 

                const imageUrl = puzzleImages[currentPuzzleImageIndex];
                currentPuzzleImageIndex = (currentPuzzleImageIndex + 1) % puzzleImages.length;
                
                const pieces = [];
                for (let i = 0; i < PIECE_COUNT; i++) {
                    const piece = document.createElement('div');
                    piece.classList.add('puzzle-piece');
                    piece.setAttribute('draggable', true);
                    piece.dataset.pieceIndex = i; 
                    const row = Math.floor(i / PUZZLE_COLS);
                    const col = i % PUZZLE_COLS;
                    piece.style.backgroundImage = `url('${imageUrl}')`;
                    // Usar porcentajes para backgroundPosition
                    piece.style.backgroundPosition = `-${col * 100}% -${row * 100}%`;
                    piece.addEventListener('dragstart', handleDragStart);
                    piece.addEventListener('dragend', handleDragEnd);
                    pieces.push(piece);

                    const slot = document.createElement('div');
                    slot.classList.add('puzzle-slot');
                    slot.dataset.slotIndex = i; 
                    slot.addEventListener('dragover', handleDragOver);
                    slot.addEventListener('dragleave', handleDragLeave);
                    slot.addEventListener('drop', handleDrop);
                    puzzleGrid.appendChild(slot);
                }
                const shuffledPieces = [...pieces].sort(() => Math.random() - 0.5);
                shuffledPieces.forEach(piece => piecesContainer.appendChild(piece));
            }
            
            function checkCompletion() {
                if (correctlyPlaced === PIECE_COUNT) {
                    prizeTitle.textContent = ''; 

                    const randomIndex = Math.floor(Math.random() * prizeCodes.length);
                    const selectedCode = prizeCodes[randomIndex];
                    
                    prizeCodeEl.textContent = selectedCode; 

                    prizeModal.classList.remove('invisible', 'opacity-0'); 
                    setupAnimatedCanvas('modal-dot-canvas'); 
                }
            }

            playAgainBtn.addEventListener('click', () => {
                if (activeAnimations['modal-dot-canvas']) {
                    clearInterval(activeAnimations['modal-dot-canvas'].interval);
                    if (activeAnimations['modal-dot-canvas'].observer) {
                        activeAnimations['modal-dot-canvas'].observer.disconnect();
                    }
                    delete activeAnimations['modal-dot-canvas']; 
                }
                setupGame(); 
            });
            
            setupGame();
            setupAnimatedCanvas('dot-canvas'); 
            desyncAnimations(); 
        });
    </script>
</body>
</html>
